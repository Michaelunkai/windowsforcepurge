cd build && mkdir -Force src, include; Set-Content -Path "include\shell.h" -Value "#pragma once`n#include <string>`n#include <map>`n#include <functional>`n#include <filesystem>`n`nclass Shell {`npublic:`n    Shell();`n    void executeCommand(const std::string& input);`n`nprivate:`n    typedef void (Shell::*CommandFunction)(const std::string&);`n    std::map<std::string, CommandFunction> commands;`n`n    void initializeCommands();`n    void changeDirectory(const std::string& path);`n    void listDirectory(const std::string& path);`n    void clearScreen(const std::string& path);`n    void showHelp(const std::string& path);`n    void echo(const std::string& message);`n    void printWorkingDirectory(const std::string& path);`n    std::string executeSystemCommand(const std::string& command);`n};"; Set-Content -Path "src\shell.cpp" -Value "#include `"../include/shell.h`"`n#include <iostream>`n#include <sstream>`n#include <filesystem>`n#include <windows.h>`n#include <cstdio>`n#include <memory>`n#include <stdexcept>`n#include <string>`n#include <array>`n#include <algorithm>`n#include <vector>`n#include <fstream>`n`nnamespace fs = std::filesystem;`n`nShell::Shell()`n{`n    initializeCommands();`n}`n`nvoid Shell::initializeCommands()`n{`n    commands[`"cd`"] = &Shell::changeDirectory;`n    commands[`"dir`"] = &Shell::listDirectory;`n    commands[`"ls`"] = &Shell::listDirectory;`n    commands[`"clear`"] = &Shell::clearScreen;`n    commands[`"cls`"] = &Shell::clearScreen;`n    commands[`"help`"] = &Shell::showHelp;`n    commands[`"echo`"] = &Shell::echo;`n    commands[`"pwd`"] = &Shell::printWorkingDirectory;`n}`n`nvoid Shell::executeCommand(const std::string &input)`n{`n    std::istringstream iss(input);`n    std::string command;`n    iss >> command;`n`n    if (commands.find(command) != commands.end())`n    {`n        std::string args;`n        std::getline(iss, args);`n        // Trim leading whitespace from args`n        args.erase(0, args.find_first_not_of(`" \t`"));`n        (this->*commands[command])(args);`n    }`n    else`n    {`n        executeSystemCommand(input);`n    }`n}`n`nvoid Shell::changeDirectory(const std::string &path)`n{`n    try`n    {`n        if (path.empty() || path == `" `")`n        {`n            // Print current directory if no path specified`n            std::cout << fs::current_path().string() << std::endl;`n            return;`n        }`n`n        fs::path newPath = path;`n        fs::current_path(newPath);`n    }`n    catch (const fs::filesystem_error &e)`n    {`n        std::cerr << `"Error: `" << e.what() << std::endl;`n    }`n}`n`nvoid Shell::listDirectory(const std::string &path)`n{`n    try`n    {`n        fs::path dirPath = path.empty() ? fs::current_path() : fs::path(path);`n`n        for (const auto &entry : fs::directory_iterator(dirPath))`n        {`n            HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);`n`n            if (fs::is_directory(entry))`n            {`n                SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_INTENSITY);`n                std::cout << `"[DIR] `";`n            }`n            else`n            {`n                SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_INTENSITY);`n                std::cout << `"[FILE] `";`n            }`n`n
  std::cout << entry.path().filename().string() << std::endl;`n`n            // Reset color`n            SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);`n        }`n    }`n    catch (const fs::filesystem_error &e)`n    {`n        std::cerr << `"Error: `" << e.what() << std::endl;`n    }`n}`n`nvoid Shell::clearScreen(const std::string &)`n{`n    system(`"cls`");`n}`n`nvoid Shell::showHelp(const std::string &)`n{`n    std::cout << `"Available commands:\n`";`n    std::cout << `"  cd [path]     - Change directory\n`";`n    std::cout << `"  dir/ls [path] - List directory contents\n`";`n    std::cout << `"  clear/cls     - Clear screen\n`";`n    std::cout << `"  echo [text]   - Display text\n`";`n    std::cout << `"  pwd          - Print working directory\n`";`n    std::cout << `"  help         - Show this help message\n`";`n    std::cout << `"  exit         - Exit the shell\n`";`n}`n`nvoid Shell::echo(const std::string &message)`n{`n    std::cout << message << std::endl;`n}`n`nvoid Shell::printWorkingDirectory(const std::string &)`n{`n    std::cout << fs::current_path().string() << std::endl;`n}`n`nstd::string Shell::executeSystemCommand(const std::string &command)`n{`n    std::array<char, 128> buffer;`n    std::string result;`n`n    // Create a pipe to execute the command`n    auto pipe = _popen(command.c_str(), `"r`");`n`n    if (!pipe)`n    {`n        throw std::runtime_error(`"popen() failed!`");`n    }`n`n    // Read the output`n    while (fgets(buffer.data(), buffer.size(), pipe) != nullptr)`n    {`n        std::cout << buffer.data();`n        result += buffer.data();`n    }`n`n    auto rc = _pclose(pipe);`n`n    if (rc != 0)`n    {`n        // If the command wasn't found or failed to execute`n        if (result.empty())`n        {`n            std::cerr << `"'`" << command << `"' is not recognized as an internal or external command,\n`";`n            std::cerr << `"operable program or batch file.\n`";`n        }`n    }`n`n    return result;`n}"; Set-Content -Path "src\main.cpp" -Value "#include `"../include/shell.h`"`n#include <iostream>`n#include <string>`n`nint main() {`n    Shell shell;`n    std::string input;`n`n    std::cout << `"PowerShell Simulator v1.0\n`";`n    std::cout << `"Type 'help' for available commands. Type 'exit' to quit.\n`";`n`n    while (true) {`n        std::cout << `"PS `" << std::filesystem::current_path().string() << `"> `";`n        std::getline(std::cin, input);`n`n        if (input == `"exit`") {`n            break;`n        }`n`n        if (!input.empty()) {`n            shell.executeCommand(input);`n        }`n    }`n`n    return 0;`n}"; g++ -std=c++17 src\main.cpp src\shell.cpp -o powershell_sim.exe; .\powershell_sim.exe
